{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Cloak Documentation","text":"<p>Welcome to the documentation site for Cloak \u2014 the pragmatic confidentiality solution developed by Scroll. On this site, you can learn about Cloak's design philosophy and technical details. We will also show how you can integrate Cloak into your system.</p> <p>Warning</p> <p>As of October 2025, Cloak is still experimental, unaudited software.</p>"},{"location":"#what-is-cloak","title":"What is Cloak?","text":"<p>Rollups and stablecoins are effective tools of financial inclusion: They offer cheap, secure, programmable access to cross-border transfers, higher yield, and many more services that individuals and companies around the world need. Projects like Xen, USX, Ether.fi, and Shiga all build towards these goals.</p> <p>However, in the current web3 landscape, lack of confidentiality is a major pain point for users. Token balances and transactions are all public by default. Existing privacy tools are complex, expensive, and raise compliance risks.</p> <p>Cloak is a pragmatic confidentiality solution.</p> <ul> <li> <p>As an L3 validium appchain, Cloak proves every transaction using Scroll's zkEVM technology, ensuring that state can only be updated according to the protocol rules.</p> </li> <li> <p>Cloak achieves confidentiality via fine-grained access control.   This allows only chain operators and regulators to access the data.   Users can freely access their own accounts, but they cannot query other users' data.</p> </li> <li> <p>Cloak allows interoperability with the host chain via fast deposits and fast withdrawals.</p> </li> </ul> <p>Cloak is a reusable technology stack, built using Scroll's battle-tested rollup technology. You can deploy new, isolated instances of Cloak on Scroll or any other EVM chain.</p>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>Visit the Integration Guide to learn how you can use Cloak in your system.</li> <li>Go to the Technology section to get an in-depth overview of how Cloak works under the hood.</li> </ul>"},{"location":"glossary/","title":"Glossary of Technical Terms","text":"<ul> <li> <p>Confidentiality chain:   A private blockchain that ensures confidentiality of user data.   Usually deployed as an L3 validium.</p> </li> <li> <p> Deposit:   The act of moving tokens from the host chain to the confidentiality chain.</p> </li> <li> <p> Host chain:   The chain on which the confidentiality chain is deployed.   Typically this is Scroll (and L2), in which case the confidentiality chain is an L3.   The host chain ensures the security of the confidentiality chain, by storing data commitments and verifying ZK proofs.   Users can deposit from and withdraw back to the host chain.</p> </li> <li> <p> L3 chain:   A chain deployed on top of an L2 like Scroll, inheriting (part of) its security.</p> </li> <li> <p> Rollup:   Rollups are L2 chains that post data to their host chain (Ethereum L1), as well as validity proofs to ensure that the L2 state transitions were correct.</p> </li> <li> <p> Validium:   Just like rollups, validium chains post validity proofs to their host chain.   However, validiums do not post data, so 3rd-parties cannot independently rebuild the validium state.</p> </li> <li> <p> Withdrawal:   The act of moving tokens from the confidentiality chain back to the host chain.</p> </li> <li> <p> zkEVM:   A mechanism for producing and verifying validity proofs for EVM execution.   Succinct validity proofs (also known as ZK proofs) attest that the chain operator executed all transactions correctly, following the EVM protocol rules.</p> </li> </ul>"},{"location":"integration/address-book/","title":"Cloak Devnet Address Book","text":"<p>Warning</p> <p>Cloak is still under active development. Expect the devnets to be reset and redeployed regularly.</p> <p>Below you can find the public devnet addresses for a Cloak instance on the Scroll Sepolia testnet, and on Scroll mainnet. These devnets can be used for experimenting with Cloak and for testing integrations. For production deployment, you should contract the Scroll team to set up a dedicated instance of Cloak.</p> <p>See the up-to-date address books in the <code>@scroll-tech/cloak-js</code> package <code>chains</code> file.</p> Cloak devnet on Scroll SepoliaCloak devnet on Scroll mainnet <p>Deployment on 2025-09-12 with salt <code>sepolia-test-004</code>.</p> Contract name Contract address <code>HostWeth</code> <code>0x5300000000000000000000000000000000000004</code> <code>HostValidium</code> <code>0x230451558C226FC8a179F99F8D04C702dcf0341D</code> <code>HostMessageQueue</code> <code>0x728C30d80e0a5d7C5369A20AdCD3DAB813085599</code> <code>HostMessenger</code> <code>0x2b212737722a674e3cdCc129B04689a1a5fe99a8</code> <code>HostERC20Gateway</code> <code>0xDAbfBE555e3ea13e7d3EB942aa97134Ac2eE153f</code> <code>HostWethGateway</code> <code>0xED46830F8C590c182a2a6d4f8E00B99fDF4A80F1</code> <code>HostFastWithdrawVault</code> <code>0x5e30821a32F65bbf474B280806d23674dB565939</code> <code>ValidiumMessageQueue</code> <code>0x5300000000000000000000000000000000000000</code> <code>ValidiumMessenger</code> <code>0xF14806ed231A42fE57163Bd200f064c7cE429840</code> <code>ValidiumERC20Gateway</code> <code>0x2C7fdc2b353DF97b9DC10c987e242DfA7f949F1D</code> <p>Coming soon</p>"},{"location":"integration/auth/","title":"Authentication","text":""},{"location":"integration/auth/#introduction","title":"Introduction","text":"<p>Cloak achieves confidentiality via fine-grained access control. While Cloak supports the standard Ethereum JSON-RPC APIs, clients must present a bearer token to access data. The token scope determines what data the client can or cannot access.</p> Example: Unauthorized access<pre><code>cast rpc --rpc-url https://validium-devnet-rpc.scroll.systems eth_getBalance 0x5FDD39Bd675B5951BE2e58741c1910573A5774F1 latest\n</code></pre> <pre><code>Error: server returned an error response:\nerror code -32603: unauthorized, data: \"unauthorized\" # (1)!\n</code></pre> <ol> <li>The RPC method <code>eth_getBalance</code> is token-gated.    We did not specify a bearer token, so we get an <code>unauthorized</code> error.</li> </ol>"},{"location":"integration/auth/#admin-tokens","title":"Admin Tokens","text":"<p>If you access a Cloak instance via a secure backend, then you can acquire an admin token. In the following examples, we use the example admin token <code>admin-token-1-abcdefg</code>.</p> castviemethers-js Example: Admin token<pre><code>cast rpc --rpc-url https://validium-devnet-rpc.scroll.systems --rpc-headers \"Authorization: Bearer admin-token-1-abcdefg\" eth_getBalance 0x5FDD39Bd675B5951BE2e58741c1910573A5774F1 latest\n</code></pre> Example: Admin token<pre><code>const { createPublicClient, http } = require('viem');\n\nconst endpoint = 'https://validium-devnet-rpc.scroll.systems';\nconst token = 'admin-token-1-abcdefg';\nconst address = '0x5FDD39Bd675B5951BE2e58741c1910573A5774F1';\n\nconst opts = {\n  fetchOptions: {\n    headers: {\n      Authorization: `Bearer ${token}`,\n    }\n  }\n};\n\nconst client = createPublicClient({ transport: http(endpoint, opts) });\n\nawait client.getBalance({ address });\n</code></pre> Example: Admin token<pre><code>const { ethers } = require('ethers');\n\nconst endpoint = 'https://validium-devnet-rpc.scroll.systems';\nconst token = 'admin-token-1-abcdefg';\nconst address = '0x5FDD39Bd675B5951BE2e58741c1910573A5774F1';\n\nconst request = new ethers.FetchRequest(endpoint);\nrequest.setHeader('Authorization', `Bearer ${token}`);\nconst provider = new ethers.JsonRpcProvider(request);\n\nconst balance = await provider.getBalance(address);\n</code></pre> <p>Requests using an admin token can access all data.</p> <p>Warning about admin token security</p> <p>Admin tokens allow access to sensitive data. It is important that they are stored securely and rotated regularly.</p>"},{"location":"integration/auth/#siwe-jwt-tokens","title":"SIWE JWT Tokens","text":"<p>Cloak supports Sign-In with Ethereum (SIWE), which allows users to authenticate using their wallet. The user must sign a message proving that they have access to their private key. After verifying the signature, the RPC endpoint issues a scoped JWT token. Using this token, the user can then access data related to their own account.</p> <p>The login flow is the following:</p> <pre><code>sequenceDiagram\n  autonumber\n  client-&gt;&gt;rpc: siwe_getNonce\n  Note right of rpc: Generate unique nonce\n  rpc--&gt;&gt;client: nonce\n  Note left of client: Construct and sign &lt;br&gt; SIWE message\n  client-&gt;&gt;rpc: siwe_signIn\n  Note right of rpc: Verify message and signature\n  rpc--&gt;&gt;client: jwt token\n  Note left of client: Configure token &lt;br&gt; on provider\n  client-&gt;&gt;rpc: eth_getBalance\n  rpc--&gt;&gt;client: 1234</code></pre> <p>You can use any SIWE libraries, or any library capable of EIP-712 typed structured data hashing and signing. Below is an example using siwe-js with <code>ethers</code>.</p> <ol> <li> <p>Acquire a unique nonce via <code>siwe_getNonce</code>.</p> Example: SIWE with browser wallet (1/3)<pre><code>const { ethers } = require('ethers');\nconst { SiweMessage } = require('siwe');\n\nconst endpoint = 'https://validium-devnet-rpc.scroll.systems';\n\nconst wallet = new ethers.BrowserProvider(window.ethereum);\nconst provider = new ethers.JsonRpcProvider(endpoint);\n\n// connect wallet\nawait wallet.send('eth_requestAccounts', []);\nconst signer = await wallet.getSigner();\n\n// fetch nonce\nconst nonce = await provider.send('siwe_getNonce', []);\n</code></pre> </li> <li> <p>Construct and sign SIWE message.</p> Example: SIWE with browser wallet (2/3)<pre><code>// construct siwe message\nconst network = await provider.getNetwork();\n\nconst draft = new SiweMessage({\n  domain: window.location.host,\n  address: signer.address,\n  statement: 'Sign in with Ethereum to the app.',\n  uri: endpoint,\n  version: '1',\n  chainId: network.chainId,\n  nonce,\n});\n\nconst message = draft.prepareMessage();\n\n// prompt wallet signature\nconst signature = await signer.signMessage(message);\n</code></pre> </li> <li> <p>Submit signature via <code>siwe_signIn</code> to acquire a JWT token.</p> Example: SIWE with browser wallet (3/3)<pre><code>// submit signature to acquire jwt token\nconst jwt = await provider.send('siwe_signIn', [message, signature]);\n\n// create authenticated provider\nconst request = new ethers.FetchRequest(endpoint);\nrequest.setHeader('Authorization', `Bearer ${jwt}`);\nconst authProvider = new ethers.JsonRpcProvider(request);\n\nconst balance = await authProvider.getBalance(signer.address);\n</code></pre> </li> </ol>"},{"location":"integration/deposits/","title":"Depositing Funds to Cloak","text":""},{"location":"integration/deposits/#introduction","title":"Introduction","text":"<p>Most Cloak instances are deployed as L3 chains on top of Scroll. That means that there is a canonical smart contract token bridge between Scroll and Cloak.</p> <p>The general deposit process for Cloak chain operators is:</p> <ol> <li>Bridge assets to Scroll via the canonical bridge (from Ethereum) or via 3rd-party bridges.</li> <li>Deposit to Cloak via the Cloak bridge.</li> </ol> <p>The remainder of this document will focus on Step 2.</p> <p>Integration options</p> <p>For bridging your users' assets to Cloak, you can implement the above process in your frontend. Alternatively, you can also implement your own liquidity bridge by bridging a certain amount of tokens to Cloak, and distributing them to users based on your application logic.</p>"},{"location":"integration/deposits/#overview-of-the-cloak-bridge","title":"Overview of the Cloak Bridge","text":"<p>The Cloak bridge implements a general message-passing interface between L2 (Scroll) and L3 (Cloak). Most of the bridge code is inherited from the Scroll bridge.</p> <ul> <li>The user calls one of the token gateway contracts to initiate the deposit: <code>HostERC20Gateway.depositERC20</code> or <code>HostETHGateway.depositETH</code>.</li> <li>The token gateway relays the message to <code>HostMessenger</code>, which enqueues a message on <code>HostMessageQueue</code>.</li> <li>The L3 sequencer node picks up the message and relays it to Cloak via <code>ValidiumERC20Gateway</code>.</li> </ul> <p>Most of the above contracts are implementation details; users generally mainly interact with the gateway contracts.</p>"},{"location":"integration/deposits/#a-note-on-stealth-deposits","title":"A Note on Stealth Deposits","text":"<p>Unlike the Scroll bridge, the Cloak bridge uses stealth deposits, meaning that the deposit target address is encrypted. This is necessary, so that the L3 confidential identity is not exposed publicly on L2. We also want to avoid easily linking L2 and L3 accounts.</p>"},{"location":"integration/deposits/#prerequisites","title":"Prerequisites","text":"<p>We recommend using the <code>@scroll-tech/cloak-js</code> package. This package provides the Cloak network configurations, and tools for encrypting and tracking deposits. It supports <code>viem</code> and <code>ethers-js</code>.</p> <p>To use this package in your JavaScript or TypeScript project, simply install and then import it:</p> <pre><code>import { abis, cloak } from '@scroll-tech/cloak-js';\n\nconst c = cloak('local-devnet');\nconsole.log(c.contracts());\n</code></pre>"},{"location":"integration/deposits/#depositing-eth-to-cloak","title":"Depositing ETH to Cloak","text":"<p>See the full example at deposit-eth.ts example in the <code>@scroll-tech/cloak-js</code> package.</p> <p>The deposit process is as follows.</p> <ol> <li> <p>Fetch the current encryption key.</p> viemethers <pre><code>const [keyId, encryptionKey] = await l2Client.readContract({\n  address: c.contracts().HostValidium,\n  abi: abis.HostValidium,\n  functionName: 'getLatestEncryptionKey',\n});\n</code></pre> <pre><code>const validium = new Contract(\n  c.contracts().HostValidium,\n  abis.HostValidium,\n  l2Provider,\n);\n\nconst [keyId, encryptionKey] = await validium.getLatestEncryptionKey();\n</code></pre> </li> <li> <p>Encrypt the target address using the encryption key.</p> <pre><code>const recipient = c.encryptAddress(l3Address/* (1)! */, encryptionKey);\n</code></pre> <ol> <li>It is recommended to generate a unique L3 address for the user.    One that is not used on another networks.</li> </ol> </li> <li> <p>Send the deposit to the L2 bridge.</p> viemethers <pre><code>await l2Wallet.writeContract({\n  address: c.contracts().HostWethGateway,\n  value: amount,\n  abi: abis.HostWethGateway,\n  functionName: 'deposit',\n  args: [recipient, amount, keyId],\n});\n</code></pre> <pre><code>const hostWethGateway = new Contract(\n  c.contracts().HostWethGateway,\n  abis.HostWethGateway,\n  l2Wallet,\n);\n\nconst tx = await hostWethGateway.deposit(recipient, amount, keyId, {\n  value: amount,\n});\n</code></pre> </li> <li> <p>Set up deposit tracking.</p> <pre><code>const deposit = c.trackDeposit(l2Receipt, l3Account.address);\n</code></pre> </li> <li> <p>Wait for the deposit to be confirmed on L3.</p> viemethers <pre><code>const hash = deposit.possibleL3TxHashes.decrypted;\nconst l3Receipt = await l3Client.waitForTransactionReceipt({ hash });\n</code></pre> <pre><code>const hash = deposit.possibleL3TxHashes.decrypted;\nconst l3Receipt = await l3Provider.waitForTransaction(hash);\n</code></pre> </li> </ol>"},{"location":"integration/deposits/#depositing-erc20-tokens-to-cloak","title":"Depositing ERC20 Tokens to Cloak","text":"<p>See the full example at deposit-erc20.ts example in the <code>@scroll-tech/cloak-js</code> package.</p> <p>ERC20 deposits are similar to ETH deposits, but they happen through the <code>ERC20Gateway</code> and require a token approval transaction on L2.</p> <ol> <li> <p>Fetch the current encryption key.</p> viemethers <pre><code>const [keyId, encryptionKey] = await l2Client.readContract({\n  address: c.contracts().HostValidium,\n  abi: abis.HostValidium,\n  functionName: 'getLatestEncryptionKey',\n});\n</code></pre> <pre><code>const validium = new Contract(\n  c.contracts().HostValidium,\n  abis.HostValidium,\n  l2Provider,\n);\n\nconst [keyId, encryptionKey] = await validium.getLatestEncryptionKey();\n</code></pre> </li> <li> <p>Encrypt the target address using the encryption key.</p> <pre><code>const recipient = c.encryptAddress(l3Address, encryptionKey);\n</code></pre> </li> <li> <p>Approve the Cloak bridge to spend your ERC20 token.</p> viemethers <pre><code>await l2Wallet.writeContract({\n  address: l2Token,\n  abi: abis.ERC20,\n  functionName: 'approve',\n  args: [c.contracts().HostERC20Gateway, amount],\n});\n</code></pre> <pre><code>const erc20 = new Contract(l2Token, abis.ERC20, l2Wallet);\n\nconst approveTx = await erc20.approve(\n  c.contracts().HostERC20Gateway,\n  amount,\n);\n</code></pre> </li> <li> <p>Send the deposit to the L2 bridge.</p> viemethers <pre><code>await l2Wallet.writeContract({\n  address: c.contracts().HostERC20Gateway,\n  abi: abis.HostERC20Gateway,\n  functionName: 'depositERC20',\n  args: [l2Token, recipient, amount, gasLimit, keyId],\n});\n</code></pre> <pre><code>const hostERC20Gateway = new Contract(\n  c.contracts().HostERC20Gateway,\n  abis.HostERC20Gateway,\n  l2Wallet,\n);\n\nawait hostERC20Gateway.depositERC20(\n  l2Token,\n  recipient,\n  amount,\n  gasLimit,\n  keyId,\n);\n</code></pre> </li> <li> <p>Set up deposit tracking.</p> <pre><code>const deposit = c.trackDeposit(l2Receipt, l3Account.address);\n</code></pre> </li> <li> <p>Wait for the deposit to be confirmed on L3.</p> viemethers <pre><code>const hash = deposit.possibleL3TxHashes.decrypted;\nconst l3Receipt = await l3Client.waitForTransactionReceipt({ hash });\n</code></pre> <pre><code>const hash = deposit.possibleL3TxHashes.decrypted;\nconst l3Receipt = await l3Provider.waitForTransaction(hash);\n</code></pre> </li> </ol>"},{"location":"integration/deposits/#erc20-token-mapping","title":"ERC20 Token Mapping","text":"<p>The Scroll-Cloak bridge can permissionlessly bridge any valid ERC20 token. The bridge will deterministically compute the corresponding L3 token address, which will not change after the first deposit. L2 ETH is bridged into L3 Wrapped ETH.</p> <p>ETH deposits</p> <p>By default, L2 ETH is deposited into L3 Wrapped ETH (ERC20 token), not into the L3 gas token. L3 gas is free, so users do not need to hold any gas token.</p> <p>The L2-L3 token mapping can be queried via the <code>HostERC20Gateway</code> contract on L2:</p> viemethers <pre><code>const l3TokenAddress = await l2Client.readContract({\n  address: c.contracts().HostERC20Gateway,\n  abi: abis.HostERC20Gateway,\n  functionName: 'getL2ERC20Address',\n  args: [c.contracts().HostWeth],\n});\n</code></pre> <pre><code>const hostERC20Gateway = new Contract(\n  c.contracts().HostERC20Gateway,\n  abis.HostERC20Gateway,\n  l2Wallet,\n);\n\nconst l3Token = await hostERC20Gateway.getL2ERC20Address(l2Token);\n</code></pre>"},{"location":"integration/faq/","title":"Frequently Asked Questions","text":"<p>This page is currently empty.</p>"},{"location":"integration/overview/","title":"Cloak Integration Guide","text":"<p>This guide will walk you through the main steps of integrating Cloak into your system.</p> <ul> <li>Visit Use cases to learn about ways your system can leverage Cloak.</li> <li>Understand the main steps of using Cloak in your system: Authenticating with the Cloak RPC endpoint, depositing funds from Scroll to Cloak, making transfers between different accounts on Cloak, and withdrawing funds from Cloak back to Scroll.</li> <li>See Address book for a reference of the latest deployment addresses of the Cloak devnet.</li> <li>Visit the FAQ for troubleshooting.</li> </ul> <p>Most code examples in these pages use Javascript with <code>ethers</code>. However, Cloak is language-agnostic. If your system uses a different programming language, reach out to discuss SDK support.</p>"},{"location":"integration/transfers/","title":"Making Transfers inside Cloak","text":""},{"location":"integration/transfers/#introduction","title":"Introduction","text":"<p>Cloak is an exact copy of Scroll's EVM. As it is a full fledged EVM execution environment, one can do ERC20 token transfers or interact with smart contracts.</p> <p>The simplest use case is to let users hold tokens in a wallet on Cloak (similar to a shielded account) and to make transfers to other users. In this document we will present this use case.</p>"},{"location":"integration/transfers/#making-token-transfers","title":"Making Token Transfers","text":"<p>See the full example at transfer.ts example in the <code>@scroll-tech/cloak-js</code> package.</p> <p>To make ERC20 transfers (for L3 WETH or any other deposited token), simply call the token contract <code>transfer</code> function, just like you would on other EVM chains.</p> viemethers <pre><code>import { abis, cloak } from '@scroll-tech/cloak-js';\n\nconst c = cloak('local-devnet');\n\n// configure client with access token...\n\nconst hash = await l3Wallet.writeContract({\n  address: c.contracts().ValidiumWeth,\n  abi: abis.ERC20,\n  functionName: 'transfer',\n  args: [recipient.address, amount],\n});\n\nconst receipt = await l3Client.waitForTransactionReceipt({ hash });\n</code></pre> <pre><code>import { abis, cloak } from '@scroll-tech/cloak-js';\n\nconst c = cloak('local-devnet');\n\n// configure client with access token...\n\nconst validiumWeth = new Contract(\n  c.contracts().ValidiumWeth,\n  abis.ERC20,\n  l3Wallet,\n);\n\nconst tx = await validiumWeth.transfer(recipient.address, amount);\n</code></pre> <p>By default, this transaction and transaction receipt can only be queried by the sender and the recipient, as well as the chain admins. Other users cannot access this information.</p>"},{"location":"integration/use-cases/","title":"Use Cases","text":""},{"location":"integration/use-cases/#introduction","title":"Introduction","text":"<p>Using Cloak as a building block in your wallet or dapp infrastructure, you can implement various use cases. This page will present the most common ones. Welcome to contact the Scroll team for exploring new features and use cases.</p> <p>Warning</p> <p>Cloak is a pragmatic solution to on-chain confidentiality. As such, it does not aim to offer absolute privacy guarantees. It is important to inform your users about the risks and limitations.</p>"},{"location":"integration/use-cases/#shielded-balances-and-confidential-transfers","title":"Shielded Balances and Confidential Transfers","text":"<p>The simplest use case for Cloak is for a wallet to offer confidential (shielded) balances. The users flow would be as follows:</p> <ol> <li> <p>Fund confidential account.    The wallet guides the user to bridge funds to Scroll, and then to deposit to a unique address on Cloak.    Most of the complexities of bridging and depositing can be hidden from the user. The following swimlane graph shows the flow transferring from a public wallet to a private one.</p> <pre><code>sequenceDiagram\n   participant Sender as Sender (0x123)\n   participant Base as Base\n   participant Scroll as Scroll\n   participant Cloak as Cloak\n   participant Recipient as Recipient (0x456)\n\n   Sender-&gt;&gt;Base: Bridge 0x123 -&gt; Scroll 0x123&lt;br/&gt;msg: \"deposit to Cloak 0x456\"\n   Base--&gt;&gt;Scroll: Lock token &amp; relay deposit event \"to 0x123\"\n   Scroll-&gt;&gt;Sender: Credit on Scroll 0x123\n   Sender-&gt;&gt;Scroll: Deposit to Cloak (target 0x456)\n   Note over Scroll: Encrypt &amp; randomize recipient&lt;br/&gt;0x456 -&gt; 0x789\n   Scroll--&gt;&gt;Cloak: Lock token &amp; relay deposit event \"to 0x789\"\n   Note over Cloak: Decrypt 0x789 -&gt; 0x456\n   Cloak-&gt;&gt;Recipient: Credit on Cloak to 0x456</code></pre> </li> <li> <p>Keep balance in confidential account.    By default, the user's tokens are in their confidential account, and cannot be queried by others.</p> </li> <li> <p>Make transfers with other confidential accounts.    For example, a merchant requests a payment from a customer.    They can exchange wallet addresses off-chain (e.g. via a QR code).    After this, the token transfer takes place between two confidential accounts on Cloak.    This transfer is not visible to any unauthorized 3rd-parties.</p> </li> <li> <p>Transfer to unsafe wallets or to other chains.    For transferring to other chains, the wallet guides the user to withdraw to Scroll, and to bridge to other chains.</p> </li> </ol>"},{"location":"integration/use-cases/#confidential-defi","title":"Confidential DeFi","text":"<p>Apart from supporting the most basic use cases of holding and transferring tokens on Cloak, it can also support more complex operations via composability with Scroll.</p> <p>Example: Swap. It is not recommended to deploy a DEX on Cloak because of liquidity constraints. Instead, dapps can utilize the fast withdraw and fast deposit features to simulate a swap inside Cloak:</p> <ol> <li>Fast-withdraw some funds to a new address on Scroll.    It is recommended to use a new, single-use address to avoid linkability with the users previous L2 and L3 identities.</li> <li>Make a swap on Scroll.</li> <li>Deposit the received tokens back to Cloak.</li> </ol> <p>The dapp can execute these three operations quickly, or even batch them into a single operation. This way, for the user this all happens in a single step within a few seconds.</p>"},{"location":"integration/withdrawals/","title":"Withdrawing Funds","text":""},{"location":"integration/withdrawals/#introduction","title":"Introduction","text":"<p>Withdrawals are the counterpart of deposits: they are transactions that move tokens from Cloak (L3) back to the host chain (Scroll).</p> <p>Cloak offers two ways to withdraw funds:</p> <ol> <li> <p>Slow withdrawals:    Same mechanism as Scroll:    The user submits a withdraw transaction on L3, waits for it to be finalized (validity proof submitted on the host chain), then claims on L2 using a Merkle proof.    This withdraw path has guaranteed liquidity from the L2 bridge (since assets are locked 1:1), but having to wait for finalization makes it slow.</p> </li> <li> <p>Fast withdrawals:    Alternatively, we offer a sequencer-maintained liquidity bridge.    The user submits a withdraw transaction to the host <code>FastWithdrawVault</code> contract.    The Cloak sequencer checks that the transaction is valid.    If the checks are passed, the sequencer immediately releases funds to the user on L2.    This withdraw path is very fast, but requires liquidity management from the sequencer, and as such it might fail if the vault is depleted.</p> </li> </ol> <p>We recommend using fast withdrawals for frequent, low-value withdrawals, and slow withdrawals for large-value transactions.</p>"},{"location":"integration/withdrawals/#slow-withdrawals-withdrawing-via-the-canonical-bridge","title":"Slow Withdrawals: Withdrawing via the Canonical Bridge","text":"<p>See the full example at withdraw.ts example in the <code>@scroll-tech/cloak-js</code> package.</p> <p>In all cases, withdrawals are initiated via the <code>ValidiumERC20Gateway.withdrawERC20AndCall</code> method.</p> viemethers <pre><code>const withdrawalHash = await l3Wallet.writeContract({\n  chain: null,\n  address: c.contracts().ValidiumERC20Gateway,\n  abi: abis.ValidiumERC20Gateway,\n  functionName: 'withdrawERC20AndCall',\n  args: [l3Token, l2Account.address, amount, '0x', 0n],\n});\n\nconst withdrawalReceipt = await l3Client.waitForTransactionReceipt({\n  hash: withdrawalHash\n});\n</code></pre> <pre><code>const erc20Gateway = new Contract(\n  c.contracts().ValidiumERC20Gateway,\n  abis.ValidiumERC20Gateway,\n  l3Wallet,\n);\n\nconst withdrawalTx = await erc20Gateway.withdrawERC20AndCall(\n  l3Token,\n  l2Wallet.address,\n  amount,\n  '0x',\n  0n,\n);\n</code></pre> <p>This will create a withdraw request on L3, enqueuing it on the <code>ValidiumMessageQueue</code> contract.</p> <p>Once the transaction has been proven and finalized, the withdraw proof can be queried using a special RPC endpoint:</p> viemethers <pre><code>const [w] = await l3Client.request({\n  // This RPC returns Merkle proofs for finalized withdrawals.\n  method: 'scroll_withdrawalsByTransaction',\n  params: [withdrawalHash],\n});\n</code></pre> <pre><code>const [w] = await l3Provider.send(\n  // This RPC returns Merkle proofs for finalized withdrawals.\n  'scroll_withdrawalsByTransaction',\n  [txHash],\n);\n</code></pre> <p>Finally, the user can claim on L2 using this withdraw proof:</p> viemethers <pre><code>const claimHash = await l2Wallet.writeContract({\n  chain: null,\n  address: c.contracts().HostMessenger,\n  abi: abis.HostMessenger,\n  functionName: 'relayMessageWithProof',\n  args: [\n    w.from,\n    w.to,\n    BigInt(w.value),\n    BigInt(w.nonce),\n    w.message,\n    { batchIndex: BigInt(w.batch_index), merkleProof: w.proof }\n  ],\n});\n</code></pre> <pre><code>const hostMessenger = new Contract(\n  c.contracts().HostMessenger,\n  abis.HostMessenger,\n  l2Wallet,\n);\n\nconst claimTx = await hostMessenger.relayMessageWithProof(\n  w.from,\n  w.to,\n  BigInt(w.value),\n  BigInt(w.nonce),\n  w.message,\n  { batchIndex: BigInt(w.batch_index), merkleProof: w.proof },\n);\n</code></pre>"},{"location":"integration/withdrawals/#fast-withdrawals-withdrawing-via-the-fast-withdraw-vault","title":"Fast Withdrawals: Withdrawing via the Fast Withdraw Vault","text":"<p>Fast withdrawals are still experimental.</p> <p>To use the fast withdraw vault, simply send a withdrawal with these parameters:</p> <ul> <li><code>l2Address</code> should be the <code>HostFastWithdrawVault</code> contract.</li> <li><code>payload</code> should be the target address on L2.</li> </ul> viemethers <pre><code>const withdrawalHash = await l3Wallet.writeContract({\n  chain: null,\n  address: c.contracts().ValidiumERC20Gateway,\n  abi: abis.ValidiumERC20Gateway,\n  functionName: 'withdrawERC20AndCall',\n  args: [l3Token, fastWithdrawVault/* (1)! */, amount, l2Address/* (2)! */, 0n],\n});\n\nconst withdrawalReceipt = await l3Client.waitForTransactionReceipt({\n  hash: withdrawalHash\n});\n</code></pre> <ol> <li>Withdraw target address is <code>HostFastWithdrawVault</code>, which checks the sequencer permit and releases the funds.</li> <li>The actual target address should be specified as the withdraw message payload.</li> </ol> <pre><code>const erc20Gateway = new Contract(\n  c.contracts().ValidiumERC20Gateway,\n  abis.ValidiumERC20Gateway,\n  l3Wallet,\n);\n\nconst withdrawalTx = await erc20Gateway.withdrawERC20AndCall(\n  l3Token,\n  fastWithdrawVault/* (1)! */,\n  amount,\n  l2Address/* (2)! */,\n  0n,\n);\n</code></pre> <ol> <li>Withdraw target address is <code>HostFastWithdrawVault</code>, which checks the sequencer permit and releases the funds.</li> <li>The actual target address should be specified as the withdraw message payload.</li> </ol> <p>Next, the sequencer will index this withdraw transaction and run some checks. If all checks pass, the sequencer will sign a permit authorizing the withdrawal, and it submits it on L2, releasing the tokens to the specified <code>l2Address</code>.</p>"},{"location":"technology/deep-dive/","title":"Technology Deep-Dive","text":"<p>Coming soon.</p>"},{"location":"technology/introduction/","title":"Cloak Technology Introduction","text":"<p>Coming soon.</p>"},{"location":"technology/roadmap/","title":"Project Status and Roadmap","text":"<p>Warning</p> <p>As of October 2025, Cloak is still experimental, unaudited software.</p>"},{"location":"technology/roadmap/#basic-features","title":"Basic Features","text":"<ul> <li> Validium sequencer.</li> <li> Validium contracts.</li> <li> Validium provers.</li> <li> Stealth deposits.</li> <li> Sequencer key rotations.</li> <li> Fast withdrawal service.</li> <li> Authenticated RPC gateway.</li> <li> Contract admin management.</li> <li> Production deployment.</li> <li> Detailed documentation.</li> <li> Audit.</li> <li> Open-source.</li> </ul>"},{"location":"technology/roadmap/#upcoming-features","title":"Upcoming Features","text":"<ul> <li> 2/2 Data Availability Committee.</li> </ul>"},{"location":"technology/roadmap/#projects-building-with-cloak","title":"Projects Building with Cloak","text":"<p>Coming soon.</p>"},{"location":"technology/running-locally/","title":"Running a Local Instance of Cloak","text":"<p>Coming soon.</p>"},{"location":"technology/source-code/","title":"Source Code","text":""},{"location":"technology/source-code/#main-repositories","title":"Main Repositories","text":"<p>Cloak is built on top of the following codebases. Some of these are existing Scroll components with some modifications, while others were newly developed for Cloak.</p> Codebase Repository Contracts https://github.com/scroll-tech/scroll-contracts Sequencer https://github.com/scroll-tech/go-ethereum Rollup-Node https://github.com/scroll-tech/scroll Circuits https://github.com/scroll-tech/zkvm-prover Authenticated RPC proxy https://github.com/scroll-tech/rpc-auth-proxy Fast withdraw service https://github.com/scroll-tech/cloak-fast-withdraw Withdraw proofs service https://github.com/scroll-tech/cloak-withdraw-proofs TypeScript SDK https://github.com/scroll-tech/cloak-js Devnet Coming soon"},{"location":"technology/source-code/#smart-contracts","title":"Smart Contracts","text":"<p>Main contracts deployed on Scroll (L2):</p> <ul> <li>ScrollChainValidium</li> <li>L1MessageQueue</li> <li>ScrollMessengerValidium</li> <li>L1ERC20GatewayValidium</li> <li>L1WETHGatewayValidium</li> <li>FastWithdrawVault</li> </ul> <p>Main contracts deployed on Cloak (L3):</p> <ul> <li>L2ScrollMessenger</li> <li>L2StandardERC20Gateway</li> </ul> <p>See the Address Book for the contract addresses.</p>"}]}